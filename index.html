<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Harmonic Mandala - Hover & Color</title>
    <style>
        :root { --accent: #00d2ff; --bg: #111; --panel: #1e1e1e; }
        body { background: var(--bg); color: #eee; font-family: 'Segoe UI', sans-serif; margin: 0; overflow: hidden; display: flex; height: 100vh; }
        
        /* SIDEBAR */
        #sidebar { 
            width: 340px; 
            background: var(--panel); 
            border-right: 1px solid #333; 
            display: flex; flex-direction: column; 
            z-index: 10; box-shadow: 5px 0 15px rgba(0,0,0,0.5);
        }
        .header { padding: 20px; border-bottom: 1px solid #333; }
        h2 { margin: 0; color: var(--accent); font-weight: 300; letter-spacing: 1px; }
        p { margin: 5px 0 0 0; font-size: 0.8em; color: #888; }
        
        #rings-container { flex-grow: 1; overflow-y: auto; padding: 15px; }
        
        .ring-control { 
            background: #2a2a2a; border: 1px solid #444; 
            border-radius: 6px; padding: 10px; margin-bottom: 10px; position: relative;
        }
        .ring-control h4 { margin: 0 0 8px 0; color: #888; font-size: 0.8rem; text-transform: uppercase; display: flex; justify-content: space-between; }
        .ring-remove { cursor: pointer; color: #ff4444; font-weight: bold; }
        
        select { width: 100%; padding: 8px; background: #111; border: 1px solid #555; color: white; border-radius: 4px; margin-bottom: 5px; font-size: 0.9rem; }
        
        .actions { padding: 20px; border-top: 1px solid #333; display: flex; flex-direction: column; gap: 10px; }
        button { width: 100%; padding: 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: 0.2s; }
        .btn-add { background: #333; color: #ccc; border: 1px dashed #666; }
        .btn-add:hover { background: #444; color: white; border-color: white; }
        .btn-gen { background: var(--accent); color: #000; }
        .btn-gen:hover { background: #66e0ff; }

        /* CANVAS */
        #canvas-container { flex-grow: 1; position: relative; background: radial-gradient(circle at center, #222 0%, #000 100%); cursor: crosshair; }
    </style>
</head>
<body>

<div id="sidebar">
    <div class="header">
        <h2>Harmonic Mandala</h2>
        <p>Hover over nodes to play.</p>
    </div>

    <div style="padding: 15px 15px 0 15px;">
        <label style="font-size:0.8em; color:#aaa">Seed (Center)</label>
        <div style="display:flex; gap:5px;">
            <select id="rootNote">
                <option value="C">C</option><option value="G">G</option><option value="D">D</option>
                <option value="A">A</option><option value="E">E</option><option value="B">B</option>
                <option value="F#">F#</option><option value="Db">Db</option><option value="Ab">Ab</option>
                <option value="Eb">Eb</option><option value="Bb">Bb</option><option value="F">F</option>
            </select>
            <select id="rootQuality" style="width:80px;">
                <option value="">Maj</option>
                <option value="m">Min</option>
                <option value="Maj7">Maj7</option>
            </select>
        </div>
    </div>

    <div id="rings-container"></div>

    <div class="actions">
        <button class="btn-add" onclick="addRingUI()">+ Add Ring Layer</button>
        <button class="btn-gen" onclick="generateGraph()">Regenerate Mandala</button>
    </div>
</div>

<div id="canvas-container">
    <canvas id="canvas"></canvas>
</div>

<script>
    // ==========================================
    // 1. CONFIG & DATA
    // ==========================================
    const INTERVAL_OPTIONS = [
        { val: "1", label: "Minor 2nd (1 semitone)" },
        { val: "2", label: "Major 2nd (2 semitones)" },
        { val: "3", label: "Minor 3rd (3 semitones)" },
        { val: "4", label: "Major 3rd (4 semitones)" },
        { val: "5", label: "Perfect 4th (5 semitones)" },
        { val: "6", label: "Tritone (6 semitones)" },
        { val: "7", label: "Perfect 5th (7 semitones)" },
        { val: "11", label: "Major 7th (11 semitones)" }
    ];

    const CONNECTION_OPTIONS = [
        { val: "common2", label: "Share 2 Notes (Smooth)" },
        { val: "common1", label: "Share 1 Note (Pivot)" },
        { val: "parallel", label: "Debussy Planing (Parallel)" },
        { val: "coltrane", label: "Coltrane Cycle (Maj 3rds)" },
        { val: "extend",   label: "Zappa Extension (Add Density)" }
    ];

    const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const FREQS = { "C":261.63, "C#":277.18, "D":293.66, "D#":311.13, "E":329.63, "F":349.23, "F#":369.99, "G":392.00, "G#":415.30, "A":440.00, "A#":466.16, "B":493.88 };

    // ==========================================
    // 2. HELPER FUNCTIONS
    // ==========================================
    
    // NEW: Color by Note Logic (Rainbow)
    function getNoteColor(chordLabel) {
        // Extract root note
        let root = chordLabel.match(/^[A-G][#b]?/)[0]; 
        let idx = NOTE_NAMES.indexOf(root);
        
        // 12 chromatic steps mapped to 360 color wheel (30 degrees each)
        // C=0(Red), D=60(Yellow), E=120(Green), G=210(Blue)
        let hue = (idx * 30) % 360; 
        return `hsl(${hue}, 80%, 50%)`;
    }

    // Extended Harmonic Parser (Zappa/Jazz support)
    function getIndices(chordName) {
        let rootStr = chordName.match(/^[A-G][#b]?/)[0];
        let root = NOTE_NAMES.indexOf(rootStr);
        let indices = [root];

        let isMin = chordName.includes("m") && !chordName.includes("Maj");
        let isMaj7 = chordName.includes("Maj7");
        let isDom7 = chordName.includes("7") && !isMaj7;
        let is9 = chordName.includes("9");
        let is11 = chordName.includes("11");

        indices.push((root + (isMin ? 3 : 4)) % 12); // 3rd
        indices.push((root + 7) % 12); // 5th
        if (isMaj7) indices.push((root + 11) % 12);
        if (isDom7 || (isMin && chordName.includes("7"))) indices.push((root + 10) % 12);
        if (is9 || is11) indices.push((root + 2) % 12); // 9th
        if (is11) indices.push((root + 5) % 12); // 11th

        return indices;
    }

    function getName(idx) { return NOTE_NAMES[(idx + 1200) % 12]; }

    // ==========================================
    // 3. UI GENERATOR
    // ==========================================
    const container = document.getElementById("rings-container");

    function createSelect(options, selectedVal) {
        return options.map(opt => `<option value="${opt.val}" ${opt.val == selectedVal ? 'selected' : ''}>${opt.label}</option>`).join('');
    }

    function addRingUI(defaultType = 'interval', defaultVal = '7') {
        const id = Math.floor(Math.random() * 10000000);
        const div = document.createElement("div");
        div.className = "ring-control";
        div.id = `ring-${id}`;
        div.innerHTML = `
            <h4>Ring ${container.children.length + 1} <span class="ring-remove" onclick="removeRing('${id}')">&times;</span></h4>
            <select class="rule-type" onchange="updateRow('${id}')">
                <option value="interval" ${defaultType === 'interval' ? 'selected' : ''}>Generate by Interval</option>
                <option value="connection" ${defaultType === 'connection' ? 'selected' : ''}>Harmonic Rule</option>
            </select>
            <select class="rule-value"></select>
        `;
        container.appendChild(div);
        updateRow(id, defaultVal);
    }

    function updateRow(id, preservedVal) {
        const div = document.getElementById(`ring-${id}`);
        const type = div.querySelector(".rule-type").value;
        const valSelect = div.querySelector(".rule-value");
        valSelect.innerHTML = createSelect(type === 'interval' ? INTERVAL_OPTIONS : CONNECTION_OPTIONS, preservedVal || (type === 'interval'?'7':'common2'));
    }

    function removeRing(id) {
        document.getElementById(`ring-${id}`).remove();
    }

    // Init UI
    addRingUI('interval', '4'); 
    addRingUI('connection', 'common2');
    addRingUI('connection', 'extend');

    // ==========================================
    // 4. GRAPH ENGINE
    // ==========================================
    let nodes = [];
    let edges = [];

    function generateNextLayer(parentChord, ruleType, ruleVal) {
        let children = [];
        let pIndices = getIndices(parentChord);
        let pRoot = pIndices[0];
        let pRootName = parentChord.match(/^[A-G][#b]?/)[0];
        let quality = parentChord.substring(pRootName.length);

        if (ruleType === 'interval') {
            let interval = parseInt(ruleVal);
            children.push(getName(pRoot + interval) + quality);
            if (interval !== 6) children.push(getName(pRoot - interval) + quality);
        } else {
            if (ruleVal === 'parallel') {
                children.push(getName(pRoot + 2) + quality, getName(pRoot - 2) + quality, getName(pRoot + 3) + quality);
            } else if (ruleVal === 'coltrane') {
                children.push(getName(pRoot + 4) + quality, getName(pRoot + 8) + quality);
            } else if (ruleVal === 'extend') {
                let newQ = !quality.includes("7") ? "Maj7" : (!quality.includes("9") ? "Maj9" : "Maj11");
                if (quality.includes("m")) newQ = newQ.replace("Maj", "m");
                children.push(pRootName + newQ);
            } else if (ruleVal.startsWith("common")) {
                let req = parseInt(ruleVal.replace("common", ""));
                for(let i=0; i<12; i++) {
                    ["", "m"].forEach(q => {
                        let cand = getName(i) + q;
                        if (cand !== parentChord) {
                            let shared = pIndices.filter(n => getIndices(cand).includes(n)).length;
                            if (shared >= req) children.push(cand);
                        }
                    });
                }
            }
        }
        return [...new Set(children)].slice(0, 6);
    }

    function generateGraph() {
        nodes = []; edges = [];
        let rootLabel = document.getElementById("rootNote").value + document.getElementById("rootQuality").value;
        
        // Root Node
        let rootNode = { id: "root", label: rootLabel, depth: 0, angle: 0, span: Math.PI * 2, x: 0, y: 0 };
        nodes.push(rootNode);

        let parents = [rootNode];
        let uiRings = Array.from(container.children);

        uiRings.forEach((div, depthIdx) => {
            let type = div.querySelector(".rule-type").value;
            let val = div.querySelector(".rule-value").value;
            let nextGen = [];
            let depth = depthIdx + 1;

            parents.forEach(p => {
                let kids = generateNextLayer(p.label, type, val);
                if (kids.length) {
                    let slice = p.span / kids.length;
                    let startAngle = p.angle - (p.span/2) + (slice/2);
                    kids.forEach((kLabel, i) => {
                        let node = {
                            id: `${p.id}_${i}`, label: kLabel, depth: depth,
                            angle: startAngle + (i * slice), span: slice, parentId: p.id, x:0, y:0
                        };
                        nodes.push(node);
                        edges.push({ from: p, to: node });
                        nextGen.push(node);
                    });
                }
            });
            parents = nextGen;
        });
        calculateLayout();
        drawCanvas();
    }

    function calculateLayout() {
        const maxDepth = nodes.reduce((m, n) => Math.max(m, n.depth), 0);
        let baseRadius = (window.innerHeight / 2) / (maxDepth + 1.5);
        nodes.forEach(n => {
            if (n.depth > 0) {
                let r = n.depth * baseRadius;
                n.x = Math.cos(n.angle - Math.PI/2) * r;
                n.y = Math.sin(n.angle - Math.PI/2) * r;
            }
        });
    }

    // ==========================================
    // 5. CANVAS & AUDIO (Hover Version)
    // ==========================================
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let cx, cy;
    let lastHoveredNode = null;

    function resize() {
        canvas.width = document.getElementById("canvas-container").offsetWidth;
        canvas.height = document.getElementById("canvas-container").offsetHeight;
        cx = canvas.width / 2; cy = canvas.height / 2;
        drawCanvas();
    }
    window.addEventListener("resize", resize);

    function playTone(freq, time) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.1, time + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 1.0);
        osc.start(time);
        osc.stop(time + 1.2);
    }

    function playChord(chordName) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        let indices = getIndices(chordName);
        indices.forEach((idx, i) => {
            let note = NOTE_NAMES[idx];
            let freq = FREQS[note];
            if (i > 0 && idx < indices[0]) freq *= 2; 
            playTone(freq, audioCtx.currentTime + (i * 0.03));
        });
    }

    function drawCanvas() {
        if (!cx) resize();
        ctx.fillStyle = "transparent";
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(cx, cy);

        // Edges
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        edges.forEach(e => {
            ctx.lineWidth = Math.max(0.5, 3 - e.to.depth);
            ctx.beginPath(); ctx.moveTo(e.from.x, e.from.y); ctx.lineTo(e.to.x, e.to.y); ctx.stroke();
        });

        // Nodes
        nodes.forEach(n => {
            let size = n.depth === 0 ? 30 : Math.max(4, 22 - (n.depth * 3));
            
            // NEW: Color Logic
            let color = getNoteColor(n.label);
            
            ctx.beginPath();
            ctx.arc(n.x, n.y, size, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();

            // Highlight if hovered
            if (n === lastHoveredNode) {
                ctx.strokeStyle = "white";
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.shadowBlur = 15;
                ctx.shadowColor = "white";
                ctx.fill(); // re-fill to apply shadow
                ctx.shadowBlur = 0;
            }

            // Text
            if (size > 8) {
                ctx.fillStyle = "#fff";
                ctx.font = "bold 12px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = "black"; ctx.shadowBlur = 4;
                ctx.fillText(n.label, n.x, n.y);
                ctx.shadowBlur = 0;
            }
        });
        ctx.restore();
    }

    // NEW: Hover Event Listener
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left - cx;
        const my = e.clientY - rect.top - cy;
        
        let foundNode = null;
        
        // Find node under mouse
        for (let i = nodes.length - 1; i >= 0; i--) {
            let n = nodes[i];
            let size = n.depth === 0 ? 30 : Math.max(4, 22 - (n.depth * 3));
            let dist = Math.sqrt((mx - n.x)**2 + (my - n.y)**2);
            if (dist < size + 2) {
                foundNode = n;
                break;
            }
        }

        if (foundNode) {
            // Only trigger if we just entered this node
            if (lastHoveredNode !== foundNode) {
                lastHoveredNode = foundNode;
                playChord(foundNode.label);
                drawCanvas();
            }
        } else {
            // Left a node
            if (lastHoveredNode !== null) {
                lastHoveredNode = null;
                drawCanvas();
            }
        }
    });

    // Start
    generateGraph();

</script>
</body>
</html>
