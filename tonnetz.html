<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dynamic Tonnetz Grid</title>
    <style>
        :root { --accent: #00d2ff; --bg: #111; --panel: #1e1e1e; }
        body { background: var(--bg); color: #eee; font-family: 'Segoe UI', sans-serif; margin: 0; overflow: hidden; display: flex; height: 100vh; }
        
        /* SIDEBAR */
        #sidebar { 
            width: 300px; background: var(--panel); border-right: 1px solid #333; 
            display: flex; flex-direction: column; z-index: 10; 
            box-shadow: 5px 0 15px rgba(0,0,0,0.5); padding: 20px; gap: 20px;
        }
        
        h2 { margin: 0; color: var(--accent); font-weight: 300; letter-spacing: 1px; }
        p { margin: 5px 0 0 0; font-size: 0.8em; color: #888; }
        
        .control-group { background: #2a2a2a; padding: 15px; border-radius: 6px; border: 1px solid #444; }
        label { display: block; font-size: 0.85em; color: #aaa; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        select { width: 100%; padding: 10px; background: #111; border: 1px solid #555; color: white; border-radius: 4px; font-size: 0.95em; }
        
        button { 
            width: 100%; padding: 12px; background: var(--accent); color: #000; 
            border: none; border-radius: 4px; font-weight: bold; cursor: pointer; transition: 0.2s; 
        }
        button:hover { background: #66e0ff; }

        /* CANVAS */
        #canvas-container { flex-grow: 1; position: relative; background: #000; cursor: crosshair; }

        /* NAV */
        nav { position: fixed; top: 0; left: 0; right: 0; height: 40px; background: #1a1a1a; border-bottom: 1px solid #333; display: flex; align-items: center; justify-content: space-between; padding: 0 20px; z-index: 100; }
        nav a { color: #aaa; text-decoration: none; font-size: 0.85em; transition: color 0.2s; }
        nav a:hover { color: var(--accent); }
        .nav-links { display: flex; gap: 20px; }
        .btn-support { background: #ffdd00; color: #000; padding: 6px 12px; border-radius: 4px; font-weight: bold; font-size: 0.8em; }
        .btn-support:hover { background: #ffe84d; color: #000 !important; }
        body { padding-top: 40px; }
    </style>
</head>
<body>

<nav>
    <div class="nav-links">
        <a href="index.html">Mandala</a>
        <a href="tonnetz.html">Tonnetz</a>
    </div>
    <a href="https://buymeacoffee.com/metallicode?new=1" class="btn-support" target="_blank">Support</a>
</nav>

<div id="sidebar">
    <div>
        <h2>Tonnetz Grid</h2>
        <p>A lattice of harmonic relationships.</p>
    </div>

    <div class="control-group">
        <label>Center Note (Origin)</label>
        <select id="rootNote">
            <option value="C">C</option><option value="G">G</option><option value="D">D</option>
            <option value="A">A</option><option value="E">E</option><option value="B">B</option>
            <option value="F#">F#</option><option value="Db">Db</option><option value="Ab">Ab</option>
            <option value="Eb">Eb</option><option value="Bb">Bb</option><option value="F">F</option>
        </select>
    </div>

    <div class="control-group">
        <label>Horizontal Axis (X)</label>
        <select id="hInterval">
            </select>
    </div>

    <div class="control-group">
        <label>Diagonal Axis (Y)</label>
        <select id="vInterval">
            </select>
    </div>

    <button onclick="drawTonnetz()">Update Grid</button>
    <p style="font-size:0.75em; color:#666; text-align:center;">Hover to play notes. <br>Lines connect harmonic neighbors.</p>
</div>

<div id="canvas-container">
    <canvas id="canvas"></canvas>
</div>

<script>
    // ==========================================
    // 1. DATA & CONFIG
    // ==========================================
    const INTERVALS = [
        { val: 1, label: "Minor 2nd (1)" },
        { val: 2, label: "Major 2nd (2)" },
        { val: 3, label: "Minor 3rd (3)" },
        { val: 4, label: "Major 3rd (4)" },
        { val: 5, label: "Perfect 4th (5)" },
        { val: 6, label: "Tritone (6)" },
        { val: 7, label: "Perfect 5th (7)" }
    ];

    const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const FREQS = { "C":261.63, "C#":277.18, "D":293.66, "D#":311.13, "E":329.63, "F":349.23, "F#":369.99, "G":392.00, "G#":415.30, "A":440.00, "A#":466.16, "B":493.88 };

    // ==========================================
    // 2. UI POPULATION
    // ==========================================
    function populateSelect(id, defaultVal) {
        const sel = document.getElementById(id);
        INTERVALS.forEach(i => {
            let opt = document.createElement("option");
            opt.value = i.val;
            opt.text = i.label;
            if (i.val === defaultVal) opt.selected = true;
            sel.appendChild(opt);
        });
    }

    populateSelect("hInterval", 7);
    populateSelect("vInterval", 4);

    // ==========================================
    // 3. GRAPH LOGIC
    // ==========================================
    let nodes = [];
    let nodeMap = {}; 
    const GRID_RADIUS = 6; 
    const NODE_SPACING = 80;

    function getNoteColor(noteIndex) {
        let hue = (noteIndex * 30) % 360; 
        return `hsl(${hue}, 75%, 55%)`;
    }

    function generateGrid() {
        nodes = [];
        nodeMap = {}; 
        
        const rootStr = document.getElementById("rootNote").value;
        const rootIdx = NOTE_NAMES.indexOf(rootStr);
        const hInt = parseInt(document.getElementById("hInterval").value);
        const vInt = parseInt(document.getElementById("vInterval").value);

        for (let q = -GRID_RADIUS; q <= GRID_RADIUS; q++) {
            for (let r = -GRID_RADIUS; r <= GRID_RADIUS; r++) {
                
                let rawIndex = (rootIdx + (q * hInt) + (r * vInt)) % 12;
                if (rawIndex < 0) rawIndex += 12;
                
                let x = NODE_SPACING * (q + (r * 0.5));
                let y = NODE_SPACING * (r * 0.866); 

                let node = {
                    id: `${q},${r}`, 
                    q: q, r: r,
                    x: x, y: y,
                    noteIndex: rawIndex,
                    noteName: NOTE_NAMES[rawIndex],
                    color: getNoteColor(rawIndex)
                };

                nodes.push(node);
                nodeMap[node.id] = node;
            }
        }
    }

    // ==========================================
    // 4. RENDERING
    // ==========================================
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let cx, cy;
    let lastHovered = null;

    function resize() {
        const container = document.getElementById("canvas-container");
        canvas.width = container.offsetWidth;
        canvas.height = container.offsetHeight;
        cx = canvas.width / 2;
        cy = canvas.height / 2;
        renderGrid(); // Call the RENAMED function
    }
    window.addEventListener("resize", resize);

    function playNote(noteName) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.frequency.value = FREQS[noteName];
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.1, now + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
        osc.start(now);
        osc.stop(now + 1.0);
    }

    // RENAMED from drawTonnetz to renderGrid to avoid conflict
    function renderGrid() {
        if (!cx) resize();
        if (nodes.length === 0) generateGrid();

        ctx.fillStyle = "#111";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        ctx.translate(cx, cy);

        // Draw Lines
        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
        ctx.lineWidth = 1.5;
        
        ctx.beginPath();
        nodes.forEach(n => {
            let right = nodeMap[`${n.q+1},${n.r}`];
            if (right) { ctx.moveTo(n.x, n.y); ctx.lineTo(right.x, right.y); }

            let downRight = nodeMap[`${n.q},${n.r+1}`];
            if (downRight) { ctx.moveTo(n.x, n.y); ctx.lineTo(downRight.x, downRight.y); }

            let downLeft = nodeMap[`${n.q-1},${n.r+1}`];
            if (downLeft) { ctx.moveTo(n.x, n.y); ctx.lineTo(downLeft.x, downLeft.y); }
        });
        ctx.stroke();

        // Draw Nodes
        nodes.forEach(n => {
            if (n.x + cx < -50 || n.x + cx > canvas.width + 50 || 
                n.y + cy < -50 || n.y + cy > canvas.height + 50) return;

            let isHover = (n === lastHovered);
            let size = 16;
            
            ctx.beginPath();
            ctx.arc(n.x, n.y, isHover ? 22 : size, 0, Math.PI * 2);
            ctx.fillStyle = n.color;
            ctx.fill();
            
            if (isHover) {
                ctx.strokeStyle = "white";
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.shadowColor = n.color;
                ctx.shadowBlur = 15;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            ctx.fillStyle = "#000"; 
            ctx.font = isHover ? "bold 14px Arial" : "11px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(n.noteName, n.x, n.y);
        });

        ctx.restore();
    }

    // This is the function attached to the button
    window.drawTonnetz = function() {
        generateGrid();
        renderGrid(); // Calls the RENAMED function, stopping the infinite loop
    }

    // ==========================================
    // 5. INTERACTION
    // ==========================================
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left - cx;
        const my = e.clientY - rect.top - cy;

        let closest = null;
        let minDst = Infinity;
        
        for (let n of nodes) {
             let dst = (mx - n.x)**2 + (my - n.y)**2;
             if (dst < minDst) {
                 minDst = dst;
                 closest = n;
             }
        }

        let realDist = Math.sqrt(minDst);

        if (closest && realDist < 25) {
            if (lastHovered !== closest) {
                lastHovered = closest;
                playNote(closest.noteName);
                renderGrid();
            }
        } else {
            if (lastHovered !== null) {
                lastHovered = null;
                renderGrid();
            }
        }
    });

    // Start
    setTimeout(() => { resize(); generateGrid(); renderGrid(); }, 100);

</script>
</body>
</html>
